\chapter{Implementierung}
\label{cha:implementierung}
In diesem Kapitel werden Teile der im Kapitel \ref{cha:konzept} beschriebenen Komponenten umgesetzt. Dabei werden exemplarisch Beispiele für ausgewählte Komponenten vorgestellt.  
Die vollständige Implementierung ist deutlich komplexer, die zugrunde liegenden Konzepte bleiben jedoch identisch, weshalb eine exemplarische Darstellung ausreichend ist.

\section{Konfiguration}
\label{sec:configuration_impl}
Im diesem Abschnitt wird beschrieben, wie die Konfiguration der zu trackenden Daten bereitgestellt und vom Manager der Konfiguration verarbeitet wird. Dabei werden die in Abschnitt \ref{sec:configuration_concept} besprochen Konzepte aufgearbeitet.

\subsection{Bereitstellung der Konfiguration}
Die Konfiguration wird pro Assembly (siehe Unterabschnitt \ref{subsec:assemblies}) bereitgestellt. Hierzu wird ein Provider im Projekt hinterlegt, der die Logik für die Ansicht und das zugehörige Presentationsmodell enthält.

Dieser Provider implementiert, wie in Programm \ref{prog:settings_provider} gezeigt, das Interface IActivityTrackingSettingsProvider mit zwei generischen Parametern. Diese Parameter definieren die Basistypen der Ansicht und des Presentationsmodells. Dies ist notwendig, um wie in Zeile 7 gezeigt zu überprüfen, ob es sich bei den angegebenen Typen tatsächlich um eine Ansicht handelt. Auf diese Weise wird der Nutzer vor einer falschen Verwendung geschützt.

Der StartSettingAccessor bildet den Einstieg in die Fluent API, über die Settings erstellt und angewendet werden können. Anschließend wird die \texttt{ProvideSettings}-Methode über Reflection (siehe Unterabschnitt \ref{subsec:reflection}) aufgerufen. Dadurch wird der Builder (siehe Unterabschnitt \ref{subsec:builder_implementation}) mit den entsprechenden Settings befüllt.

Im Beispiel aus Programm \ref{prog:settings_provider} wird sichergestellt, dass in der Aufgabenansicht erfasst wird, wie oft eine Aufgabe dupliziert wird. Hierbei werden sowohl die Bezeichnung der Funktionalität als auch ein Text für die spätere Datenanreicherung angegeben.

\begin{program}[H]
\begin{CsCode}
public class KISWinformsActivityTrackingSettingsProvider 
    : IActivityTrackingSettingsProvider<IKISStandalonePresenter, IView>
{
    public void ProvideSettings(
        IActivityTrackingStartSettingAccessor<IPresenter, IView> startSettingAccessor)
    {
        startSettingAccessor
            .TrackView<AufgabenView>()
            .GetUsage()
            .TrackFunctionality("Duplizieren", "Aufgabe dupliziert")
            .ApplySetting();
    }
}
\end{CsCode}
\caption{Bereitstellung der Tracking-Konfiguration.}
\label{prog:settings_provider}
\end{program}

\subsection{Ermittlung der Konfiguration}

Die zuvor beschriebene Konfiguration wird im dafür zuständigen Manager erzeugt, ähnlich wie der Direktor im Builder-Muster \cite{gamma1995design}. Die dafür verwendete Methode ist in Programm \ref{prog:configuration_building} dargestellt.

\begin{program}[H]
\begin{CsCode}
private async Task<bool> BuildConfigurationAsync(IAssemblyProvider assemblyProvider)
{
    try
    {
        var settingsProviderTypes = AssemblyRegisterProvider
                .LoadTypesFromBaseTypeOrInterface(
                    typeof(IActivityTrackingSettingsProvider<,>), 
                    assemblyProvider.Assemblies)
                .Where(t => t.IsClass).ToList();

        foreach (var settingsProviderType in settingsProviderTypes)
        {
            var interfaceType = settingsProviderType
                .GetInterfaces()
                .First(i => i.IsGenericType && 
                            i.GetGenericTypeDefinition() == typeof(
                                IActivityTrackingSettingsProvider<,>));

            var configurationBuilder = FindOrCreateBuilder(interfaceType);
            try
            {
                InvokeProvideSettings(
                    interfaceType, settingsProviderType, configurationBuilder);
            } catch (Exception ex){...}
        }
        foreach (var builder in _activityTrackingConfigurationBuilder)
            await builder.BuildAsync().ConfigureAwait(false);
    } catch (Exception ex){...}
    return true;
}
\end{CsCode}
\caption{Bereitstellung der Tracking-Konfiguration.}
\label{prog:configuration_building}
\end{program}

Die Methode BuildConfigurationAsync ermittelt zunächst die Typen, die als Provider für Builder Einstellungen fungieren. Hierzu wird der AssemblyRegisterProvider verwendet, welcher das Gegenstück zum AssemblyRegisterResolver (siehe Unterabschnitt \ref{sec:assembly_resolver}) darstellt. Durch einen Filter wird sichergestellt, dass nur Klassen berücksichtigt werden, da in .NET neben Klassen auch Strukturen und andere Datentypen existieren.

Anschließend wird für jeden SettingsProvider der passende Builder erzeugt. Dabei verwendet der Builder dieselben generischen Parameter wie der Provider, sodass die Einstellungen später korrekt verarbeitet werden können. Die Methode FindOrCreateBuilder sucht oder erstellt bei Bedarf einen Builder, um Duplikate in der Konfiguration zu vermeiden und die Effizienz zu steigern, indem Builder zwischengespeichert werden.

Daraufhin werden die Provider instanziiert und die Methode ProvideSettings mit einer Starteinstellung aufgerufen, die anschließend weiter spezifiziert werden kann. Diese Starteinstellung wird von dem Builder bereitgestellt, der die Wurzel des Builder Baums bildet (siehe Unterabschnitt \ref{subsec:builder_functionality_usage}). Der Aufruf erfolgt über die Methode InvokeProvideSettings, die mithilfe von Reflection arbeitet (siehe Unterabschnitt \ref{subsec:reflection}).

Nachdem die ermittelten Einstellung den entsprechenden Buildern zugewiesen wurden, erfolgt der eigentliche Aufbau der Konfiguration über die Builder. Die fertige Konfiguration kann anschließend über diese Builder abgerufen werden. Im konkreten Fall handelt es sich dabei um zwei Methoden, die zum einen den Tracking-Auftrag und zum anderen den Extraktionsauftrag liefern. Diese werden im Unterabschnitt \ref{subsec:communication_between_coponents} näher beschrieben.

\subsection{Fluent API mit Builder}
\label{subsec:builder_implementation}

Die Fluent API \cite{Fowler2005FluentInterface}, auch bekannt als Methodenverkettungsansatz, stellt eine Möglichkeit dar, eine domänenspezifische Sprache zu entwickeln, die beispielsweise eine Konfiguration lesbarer gestaltet, indem sie sich wie ein natürlicher Satz formulieren lässt. Die konkrete Anwendung dieser Fluent API wird in Kapitel \ref{cha:auswertung} näher erläutert.

Die Umsetzung in dieser Bachelorarbeit erfolgt mithilfe von Einstellungen (Settings), Buildern und Zugriffstypen für Einstellungen (Accessoren). Dabei tragen insbesondere die Settings und Accessoren maßgeblich zur Bildung der Fluent API bei, wie in diesem Unterabschnitt näher beschrieben wird.

\subsubsection{Builder}

Builder sind im Zusammenhang mit der Fluent API dafür verantwortlich, das Start-Setting bereitzustellen und somit die Verbindung zwischen dem Builder und den fertigen Settings herzustellen, die später über die ApplySetting-Methode angewendet werden. Beim Übergang zwischen den einzelnen Buildern werden aus Settings wiederum neue Builder erzeugt, die über eine zu Beginn erzeugte Referenz mit dem Hauptbuilder verknüpft werden.

Je nach Position im Konfigurationsbaum implementieren die verschiedenen Builder die in Programm \ref{prog:configuration_builder_interfaces} dargestellten Schnittstellen:

\begin{itemize}
\item \textbf{IConfigurationBuilder:} Beschreibt die grundlegenden Eigenschaften eines Builders.
\item \textbf{IRegisterableConfigurationBuilder:} Wird von Buildern implementiert, die ab der zweiten Ebene im Baum liegen und sich bei ihrem Vorgänger registrieren können.
\item \textbf{IConfigurationSettingHolder:} Repräsentiert die Blätter des Konfigurationsbaums, denen fertige Einstellungen hinzugefügt werden können.
\item \textbf{IConfigurationStartSettingProvider:} Stellt die Wurzel des Baumes dar und liefert das erste Setting, auf dessen Basis weitere Settings erzeugt werden. Diese Schnittstelle ist notwendig, da jedes Setting mit einem Builder verknüpft werden muss, um den Aufbau des Builder-Baumes zu ermöglichen.
\end{itemize}

\begin{program}[H]
\begin{CsCode}
public interface IConfigurationBuilder : IAsyncDisposable {
    bool IsBuilt { get; }
    Task BuildAsync();
}
public interface IRegisterableConfigurationBuilder<TBuilder> : IConfigurationBuilder
    where TBuilder : IConfigurationBuilder {
    void Register(IConfigurationBuilderHolder<TBuilder> predecessorBuilder);
}
public interface IConfiguationSettingHolder<TBuilder> : IConfigurationBuilder
    where TBuilder : IConfigurationBuilder {
    public void AddSetting(ICompletedConfigurationSetting<TBuilder> setting);
}
public interface IConfigurationStartSettingProvider<StartSettingType>
    where StartSettingType : IConfigurationSettingAccessor {
    StartSettingType GetActivityTrackingConfigurationStartSetting();
}
\end{CsCode}
\caption{Schnittstellen der Builder in Zusammenhang mit der Fluent API}
\label{prog:configuration_builder_interfaces}
\end{program}

\subsubsection{Settings und Accessoren}
Einstellungen müssen konfiguriert und gespeichert werden. Dazu existieren Settings, die konkrete, unveränderbare Objekte darstellen. Aus diesen können mithilfe von Accessoren weitere Einstellungen abgeleitet werden. Die Settings bilden somit ähnlich wie beim Prototyp-Muster \cite{gamma1995design} die Grundlage für weitere Konfigurationen, indem sie kopiert und erweitert werden.

Accessoren stellen die Schnittstelle dar, über die die für den Anwender sichtbare Fluent API bereitgestellt wird. Die Settings hingegen implementieren die zugehörigen Methoden und enthalten die entsprechenden, miteinander verknüpften Daten, die beim Aufbau der Konfiguration ausgelesen werden.

Programm \ref{prog:example_setting_with_accessor} zeigt ein Beispiel für den Aufbau von Accessoren und Settings. Das Setting enthält Informationen darüber, wann der weiter konfigurierte Wert einer Ansicht oder eines Präsentationsmodells ausgelesen wird. Die Eigenschaften werden dabei mithilfe eines Record-Typs \cite{microsoft_csharp_records} unter Berücksichtigung von nullable bzw. Optionalen Eigenschaften (siehe Unterabschnitt \ref{subsec:csharp_null_reference_types}) bereitgestellt.

Der Zugriffstyp IActionTriggerSettingAccessor definiert, wie das Setting weiter ausgebaut werden kann. In diesem Fall kann eine Property aus dem Kontext gewählt werden. Das daraus resultierende Setting ist, wie in der Schnittstelle beschrieben, ein vollständiges Setting, das mithilfe der ApplySetting-Methode aus dem Interface IConfigurationEndSettingAccessor dem TargetConfigurationBuilder hinzugefügt wird.

\begin{program}[H]
\begin{CsCode}
public interface IActionTriggerSettingAccessor<TContext> : IConfigurationSettingAccessor{
    IConfigurationEndSettingAccessor SelectProperty<TValue, TResult>(
        Expression<Func<TContext, TValue>> propertySelector,
        Func<TValue, TResult>? propertyConverter = null,
        string? description = null);
}
internal record ActionTriggerSetting<TContext>(
    IActivityTrackingConfigurationBuilder TargetConfigurationBuilder,
    ContextType ContextType,
    IActivityTrackingActionIdentifier Action) : IActionTriggerSettingAccessor<TContext>,IConfigurationSetting<IActivityTrackingConfigurationBuilder>
    {
    public IConfigurationEndSettingAccessor SelectProperty<TValue, TResult>(
        Expression<Func<TContext, TValue>> propertySelector,
        Func<TValue, TResult>? propertyConverter = null,
        string? description = null){
        var propertyDataProviderParameter = new PropertyDataProviderParameter(propertySelector, propertyConverter,description);
        return new DataSelectionSetting(TargetConfigurationBuilder, ContextType, 
                                        typeof(TContext), Action,
                                        propertyDataProviderParameter);
    }
}
\end{CsCode}
\caption{Beispiel für Settings und Accessoren}
\label{prog:example_setting_with_accessor}
\end{program}

\subsection{Erzeugen der Aufträge für das Datensammeln und Extrahieren}
Die gesammelten Einstellungen werden, im Builder mit der Schnittstelle IConfigurationSettingHolder zusammengeführt und beim Aufruf der Build-Methode verarbeitet. Die Builder in den darunterliegenden Schichten sind für die Delegation dieses Aufrufs sowie für die Gruppierung der untergeordneten Builder verantwortlich. Dadurch übernehmen die Blätter des Konfigurationsbaums die eigentliche Arbeit beim Aufbau der Konfiguration. Die Verarbeitung der Settings wird anhand eines Beispiels im Programm \ref{prog:example_processing_of_settings} für Tracking-Aufträge erläutert. Die Vorgehensweise für Extraktionsaufträge erfolgt analog. Wie im Programm dargestellt, leitet die Build-Methode die gesammelten Settings an die Methode BuildTrackingMissionAsync weiter. Diese Methode erzeugt für jeden Setting-Typ einen entsprechenden Auftrag für das Tracking.

\begin{program}[H]
\begin{CsCode}
protected override Task<TrackingMissionData> BuildTrackingMissionAsyn(
    IReadOnlyList<ICompletedConfigurationSetting<IActivityTrackingConfigurationBuilder>> appliedSettings) =>
        Task.FromResult(new TrackingMissionData(appliedSettings.Select(cs => {
            if (cs is DataSelectionSetting dataSelectionSetting)
            {
                return new TrackingMissionDataEntry(dataSelectionSetting.Context,
                                                    dataSelectionSetting.Action,
                                                    typeof(PropertyDataProviderTemplate),
                                                    dataSelectionSetting.PropertyParameter);
            }
            throw new NotSupportedException(...);}).ToList()));
\end{CsCode}
\caption{Beispiel für die Verarbeitung von Settings zu Tracking-Aufträgen}
\label{prog:example_processing_of_settings}
\end{program}

\section{Daten- und Aktionsermittlung}
\label{sec:data_collection_impl}
Im vorherigen Abschnitt wurde erläutert, wie die Aufträge mithilfe der Konfiguration erzeugt werden. In diesem Abschnitt wird näher beschrieben, wie diese Aufträge abgearbeitet werden und wie die einzelnen Komponenten zur Datenbeschaffung implementiert sind.

\subsection{Provider Template für Aktionen}
Um Daten zu sammeln, müssen diese, wie bereits im Unterabschnitt \ref{sec:data_extraction_concept} beschrieben, von sogenannten Providern bereitgestellt werden. Damit ein Provider Daten liefern kann, muss er sich zunächst registrieren. Nach erfolgreicher Registrierung erhält er, abhängig vom jeweiligen Trackingauftrag, Zugriff auf einen Datenkanal, über den die gesammelten Daten zur weiteren Verarbeitung bereitgestellt werden können.

Für die Implementierung dieser Provider werden im Framework Templates im Sinne des Template-Musters \cite{gamma1995design} verwendet. Diese Templates kommen sowohl für Aktionen als auch für andere Arten von Daten zum Einsatz. Da die Implementierung beider Varianten weitgehend identisch ist, wird in diesem Abschnitt das Basis-Template für Aktionen erläutert, das in Programm \ref{prog:base_template_actions} dargestellt ist. Dieses Template dient als Grundlage für aktionsspezifische Templates.

\begin{program}[H]
\begin{CsCode}
public abstract class ActivityTrackingActionProviderTemplateBase : IActivityTrackingActionProvider{
    public void Initialize(){
        var dataCollectionEntryPoint = GetDataCollectionEntryPoint();
        foreach (var context in GetContextObjects()){
            if (dataCollectionEntryPoint.TryEstablishActionProviderCollaboration(
                    this, context, out var publishChannel, out var suggestedIdentifiers))
            {
                ...
            }
        }
        ...
        InitializeCore();
    }
    public void Dispose(){
        DisposeCore();
        ...
    }
    public void CancelDataCollectionCollaboration() => Dispose();
    protected void PublishAction(IActivityTrackingAction action, Action<IActivityTrackingAction> publishChannel){
        ...
        publishChannel.Invoke(action);
    }
    protected abstract void InitializeCore();
    protected abstract void DisposeCore();
    protected abstract IActivityTrackingDataCollectionCollaborationEntryPoint GetDataCollectionEntryPoint();
    protected abstract object[] GetContextObjects();
    protected abstract string GetContextInfo(object? context);
}
\end{CsCode}
\caption{Basis Template für Aktionen}
\label{prog:base_template_actions}
\end{program}

\subsubsection{Initialisierung}
Die Methode Initialize stellt die Verbindung zum Trackingsystem über den IActivityTrackingDataCollectionCollaborationEntryPoint für die verschiedenen Kontextobjekte, wie beispielsweise Ansichten oder Präsentationsmodelle her. Diese Informationen erhält die Methode über die von der Anwendung implementierten, abstrakten Methoden.

Der EntryPoint ist im Wesentlichen ein Interface, das vom Manager der Datensammlung implementiert wird. Der jeweilige Kontext sowie Metainformationen des konkreten Templates werden beim Registrieren verwendet, um zu entscheiden, ob ein Datenkanal bereitgestellt werden soll. Bei erfolgreicher Registrierung erhält die konkrete Implementierung die Möglichkeit, weitere Initialisierungsschritte für das Tracking durchzuführen.

\subsubsection{Datenbereitstellung}
Die Methode PublishAction übernimmt den Kanal zur Bereitstellung der Daten. Dieser Kanal wird beim Registrierungsprozess hinterlegt und beim Aufruf der PublishAction-Methode übergeben. Bevor die Daten tatsächlich weitergegeben werden, erfolgen Prüfungen, beispielsweise ob die Zusammenarbeit mit dem Trackingsystem weiterhin aktiv ist.

\subsubsection{Abmeldung und Freigabe verwalteter Ressourcen}
Das Template stellt außerdem die Methoden CancelDataCollectionCollaboration und Dispose bereit, die vom Trackingsystem verwendet werden, um bei Fehlern oder bei einer gezielten Deaktivierung des Trackings im laufenden Betrieb die genutzten Ressourcen sowie die Kommunikation mit dem Trackingsystem kontrolliert zu beenden. Wie auch bei der Initialisierung müssen in den abgeleiteten Klassen die entsprechenden Methoden implementiert werden, um dort spezifische Ressourcen freizugeben.

\subsubsection{Weitere Merkmale des basis Templates}
Im Programm \ref{prog:base_template_actions} werden einige Teile ausgeblendet, um den Fokus auf den Lebenszyklus zu belassen. Denoch ist zu erwähnen das an diesen Stellen bereits eine zentrale Fehlerbehandlung vorgenommen wird. Somit wird über den gesamten Lebenszyklus sichergestellt, dass das Programm aufgrund von Trackingaktivitäten nicht zum stillstand kommt.

\subsection{Auftragsabarbeitung}
Wie bereits erwähnt, wird bei der Registrierung entschieden, ob ein Provider aktiv werden kann. Dies stellt sicher, dass Ressourcen nur dann verwendet werden, wenn sie tatsächlich benötigt werden, also konkret dann, wenn ein entsprechender Auftrag vorliegt. Wie diese Entscheidung getroffen wird, ist im Programm \ref{prog:registration_code_snipped} dargestellt. Die Entscheidung selbst wird vom Manager der Datensammlung über diese Methode vorgenommen. Bei der Registrierung werden darüber hinaus weitere Aspekte berücksichtigt, beispielsweise der Schutz vor mehrfacher Registrierung und ähnliche Validierungen.

Der zugrunde liegende Code zeigt, dass grundsätzlich jede Aktion einen Identifier mit Informationen über die Aktion bereitstellt. Dies hat den Vorteil, dass unterschiedliche Aktionen über einen gemeinsamen Identifier-Typ abgebildet werden können und die Aktionen dadurch flexibel erweiterbar sind. Auf Basis des Identifier-Typs und des jeweiligen Kontexts wird entschieden, ob ein Provider benötigt wird. Welche Aktionen ein Provider bereitstellen kann, gibt dieser über ein Attribut an, das mithilfe der Methode GetActionIdentifiersForActionProvider per Reflection  (Unterabschnitt \ref{subsec:reflection}) ausgelesen wird.

Wie zu erkennen ist, handelt es sich hierbei zunächst nur um eine grobe Einschränkung. Die eigentliche Filterung (siehe Abschnitt \ref{sec:data_extraction_impl}) erfolgt erst im Anschluss. In diesem Schritt wird lediglich entschieden, dass Daten aus einer bestimmten Ansicht und Kategorie ermittelt werden sollen.

\begin{program}[H]
\begin{CsCode}
public bool IsActionProviderRequired(IActivityTrackingActionProvider actionProvider, 
                                     object context)
{
        var availableActions = GetActionIdentifiersForActionProvider(actionProvider);

        return Entries.Any(e => 
                    e.ActionIdentifier != null && 
                    availableActions.Contains(e.ActionIdentifier.GetType()) &&
                    (e.Context == null || e.Context.IsAssignableFrom(context.GetType())));
}
private IList<Type> GetActionIdentifiersForActionProvider(
                        IActivityTrackingActionProvider actionProvider)
{
        return actionProvider
            .GetType()
            .GetCustomAttributes(typeof(ActionProviderForActionAttribute<>), true)
            .Select(ap => ap.GetType().GetGenericArguments().First())
            .ToList();
}
\end{CsCode}
\caption{Tracking Provider Registierung Entscheidungsgrundlage}
\label{prog:registration_code_snipped}
\end{program}


\section{Filterung und Extraktion}
\label{sec:data_extraction_impl}

%Asynchrone Programmierung Referenzieren

\subsection{Verarbeitungskette Ablauf}

\subsection{Extraktion Beispiel}

\section{Integration WPF}
\label{sec:integration_wpf_impl}

\subsection{Schritt zur Integration}
%MVVM Refernzieren
%Erweiterungen Referenzieren

\subsection{Beispiel Aktionen Provider}
%Eventsystem Referenzieren

\section{Integration Windows Forms}
\label{sec:integration_winforms_impl}

\subsection{Schritt zur Integration}
%Aufgabendelegation Referenzieren

\subsection{Beispiel Daten Provider}
%Referenz auf Reflection

