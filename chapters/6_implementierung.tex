\chapter{Implementierung}
\label{cha:implementierung}
In diesem Kapitel werden Teile der im Kapitel \ref{cha:konzept} beschriebenen Komponenten umgesetzt. Dabei werden exemplarisch Beispiele für ausgewählte Komponenten vorgestellt.  
Die vollständige Implementierung ist deutlich komplexer, die zugrunde liegenden Konzepte bleiben jedoch identisch, weshalb eine exemplarische Darstellung ausreichend ist.

\section{Konfiguration}
\label{sec:configuration_impl}
Im diesem Abschnitt wird beschrieben, wie die Konfiguration der zu trackenden Daten bereitgestellt und vom Manager der Konfiguration verarbeitet wird. Dabei werden die in Abschnitt \ref{sec:configuration_concept} besprochen Konzepte aufgearbeitet.

\subsection{Bereitstellung der Konfiguration}
Die Konfiguration wird pro Assembly (siehe Unterabschnitt \ref{subsec:assemblies}) bereitgestellt. Hierzu wird ein Provider im Projekt hinterlegt, der die Logik für die Ansicht und das zugehörige Presentationsmodell enthält.

Dieser Provider implementiert, wie in Programm \ref{prog:settings_provider} gezeigt, das Interface IActivityTrackingSettingsProvider mit zwei generischen Parametern. Diese Parameter definieren die Basistypen der Ansicht und des Presentationsmodells. Dies ist notwendig, um wie in Zeile 7 gezeigt zu überprüfen, ob es sich bei den angegebenen Typen tatsächlich um eine Ansicht handelt. Auf diese Weise wird der Nutzer vor einer falschen Verwendung geschützt.

Der StartSettingAccessor bildet den Einstieg in die Fluent API, über die Settings erstellt und angewendet werden können. Anschließend wird die \texttt{ProvideSettings}-Methode über Reflection (siehe Unterabschnitt \ref{subsec:reflection}) aufgerufen. Dadurch wird der Builder (siehe Unterabschnitt \ref{subsec:builder_implementation}) mit den entsprechenden Settings befüllt.

Im Beispiel aus Programm \ref{prog:settings_provider} wird sichergestellt, dass in der Aufgabenansicht erfasst wird, wie oft eine Aufgabe dupliziert wird. Hierbei werden sowohl die Bezeichnung der Funktionalität als auch ein Text für die spätere Datenanreicherung angegeben.

\begin{program}[H]
\begin{CsCode}
public class KISWinformsActivityTrackingSettingsProvider 
    : IActivityTrackingSettingsProvider<IKISStandalonePresenter, IView>
{
    public void ProvideSettings(
        IActivityTrackingStartSettingAccessor<IPresenter, IView> startSettingAccessor)
    {
        startSettingAccessor
            .TrackView<AufgabenView>()
            .GetUsage()
            .TrackFunctionality("Duplizieren", "Aufgabe dupliziert")
            .ApplySetting();
    }
}
\end{CsCode}
\caption{Bereitstellung der Tracking-Konfiguration.}
\label{prog:settings_provider}
\end{program}

\subsection{Ermittlung der Konfiguration}
\label{subsec:investigation_of_configuration}

Die zuvor beschriebene Konfiguration wird im dafür zuständigen Manager erzeugt, ähnlich wie der Direktor im Builder-Muster \cite{gamma1995design}. Die dafür verwendete Methode ist in Programm \ref{prog:configuration_building} dargestellt.

\begin{program}[H]
\begin{CsCode}
private async Task<bool> BuildConfigurationAsync(IAssemblyProvider assemblyProvider)
{
    try
    {
        var settingsProviderTypes = AssemblyRegisterProvider
                .LoadTypesFromBaseTypeOrInterface(
                    typeof(IActivityTrackingSettingsProvider<,>), 
                    assemblyProvider.Assemblies)
                .Where(t => t.IsClass).ToList();

        foreach (var settingsProviderType in settingsProviderTypes)
        {
            var interfaceType = settingsProviderType
                .GetInterfaces()
                .First(i => i.IsGenericType && 
                            i.GetGenericTypeDefinition() == typeof(
                                IActivityTrackingSettingsProvider<,>));

            var configurationBuilder = FindOrCreateBuilder(interfaceType);
            try
            {
                InvokeProvideSettings(
                    interfaceType, settingsProviderType, configurationBuilder);
            } catch (Exception ex){...}
        }
        foreach (var builder in _activityTrackingConfigurationBuilder)
            await builder.BuildAsync().ConfigureAwait(false);
    } catch (Exception ex){...}
    return true;
}
\end{CsCode}
\caption{Bereitstellung der Tracking-Konfiguration.}
\label{prog:configuration_building}
\end{program}

Die Methode BuildConfigurationAsync ermittelt zunächst die Typen, die als Provider für Builder Einstellungen fungieren. Hierzu wird der AssemblyRegisterProvider verwendet, welcher das Gegenstück zum AssemblyRegisterResolver (siehe Unterabschnitt \ref{sec:assembly_resolver}) darstellt. Durch einen Filter wird sichergestellt, dass nur Klassen berücksichtigt werden, da in .NET neben Klassen auch Strukturen und andere Datentypen existieren.

Anschließend wird für jeden SettingsProvider der passende Builder erzeugt. Dabei verwendet der Builder dieselben generischen Parameter wie der Provider, sodass die Einstellungen später korrekt verarbeitet werden können. Die Methode FindOrCreateBuilder sucht oder erstellt bei Bedarf einen Builder, um Duplikate in der Konfiguration zu vermeiden und die Effizienz zu steigern, indem Builder zwischengespeichert werden.

Daraufhin werden die Provider instanziiert und die Methode ProvideSettings mit einer Starteinstellung aufgerufen, die anschließend weiter spezifiziert werden kann. Diese Starteinstellung wird von dem Builder bereitgestellt, der die Wurzel des Builder Baums bildet (siehe Unterabschnitt \ref{subsec:builder_functionality_usage}). Der Aufruf erfolgt über die Methode InvokeProvideSettings, die mithilfe von Reflection arbeitet (siehe Unterabschnitt \ref{subsec:reflection}).

Nachdem die ermittelten Einstellung den entsprechenden Buildern zugewiesen wurden, erfolgt der eigentliche Aufbau der Konfiguration über die Builder. Die fertige Konfiguration kann anschließend über diese Builder abgerufen werden. Im konkreten Fall handelt es sich dabei um zwei Methoden, die zum einen den Tracking-Auftrag und zum anderen den Extraktionsauftrag liefern. Diese werden im Unterabschnitt \ref{subsec:communication_between_coponents} näher beschrieben.

\subsection{Fluent API mit Builder}
\label{subsec:builder_implementation}

Die Fluent API \cite{Fowler2005FluentInterface}, auch bekannt als Methodenverkettungsansatz, stellt eine Möglichkeit dar, eine domänenspezifische Sprache zu entwickeln, die beispielsweise eine Konfiguration lesbarer gestaltet, indem sie sich wie ein natürlicher Satz formulieren lässt. Die konkrete Anwendung dieser Fluent API wird in Kapitel \ref{cha:auswertung} näher erläutert.

Die Umsetzung in dieser Bachelorarbeit erfolgt mithilfe von Einstellungen (Settings), Buildern und Zugriffstypen für Einstellungen (Accessoren). Dabei tragen insbesondere die Settings und Accessoren maßgeblich zur Bildung der Fluent API bei, wie in diesem Unterabschnitt näher beschrieben wird.

\subsubsection{Builder}

Builder sind im Zusammenhang mit der Fluent API dafür verantwortlich, das Start-Setting bereitzustellen und somit die Verbindung zwischen dem Builder und den fertigen Settings herzustellen, die später über die ApplySetting-Methode angewendet werden. Beim Übergang zwischen den einzelnen Buildern werden aus Settings wiederum neue Builder erzeugt, die über eine zu Beginn erzeugte Referenz mit dem Hauptbuilder verknüpft werden.

Je nach Position im Konfigurationsbaum implementieren die verschiedenen Builder die in Programm \ref{prog:configuration_builder_interfaces} dargestellten Schnittstellen:

\begin{itemize}
\item \textbf{IConfigurationBuilder:} Beschreibt die grundlegenden Eigenschaften eines Builders.
\item \textbf{IRegisterableConfigurationBuilder:} Wird von Buildern implementiert, die ab der zweiten Ebene im Baum liegen und sich bei ihrem Vorgänger registrieren können.
\item \textbf{IConfigurationSettingHolder:} Repräsentiert die Blätter des Konfigurationsbaums, denen fertige Einstellungen hinzugefügt werden können.
\item \textbf{IConfigurationStartSettingProvider:} Stellt die Wurzel des Baumes dar und liefert das erste Setting, auf dessen Basis weitere Settings erzeugt werden. Diese Schnittstelle ist notwendig, da jedes Setting mit einem Builder verknüpft werden muss, um den Aufbau des Builder-Baumes zu ermöglichen.
\end{itemize}

\begin{program}[H]
\begin{CsCode}
public interface IConfigurationBuilder : IAsyncDisposable {
    bool IsBuilt { get; }
    Task BuildAsync();
}
public interface IRegisterableConfigurationBuilder<TBuilder> : IConfigurationBuilder
    where TBuilder : IConfigurationBuilder {
    void Register(IConfigurationBuilderHolder<TBuilder> predecessorBuilder);
}
public interface IConfiguationSettingHolder<TBuilder> : IConfigurationBuilder
    where TBuilder : IConfigurationBuilder {
    public void AddSetting(ICompletedConfigurationSetting<TBuilder> setting);
}
public interface IConfigurationStartSettingProvider<StartSettingType>
    where StartSettingType : IConfigurationSettingAccessor {
    StartSettingType GetActivityTrackingConfigurationStartSetting();
}
\end{CsCode}
\caption{Schnittstellen der Builder in Zusammenhang mit der Fluent API.}
\label{prog:configuration_builder_interfaces}
\end{program}

\subsubsection{Settings und Accessoren}
Einstellungen müssen konfiguriert und gespeichert werden. Dazu existieren Settings, die konkrete, unveränderbare Objekte darstellen. Aus diesen können mithilfe von Accessoren weitere Einstellungen abgeleitet werden. Die Settings bilden somit ähnlich wie beim Prototyp-Muster \cite{gamma1995design} die Grundlage für weitere Konfigurationen, indem sie kopiert und erweitert werden.

Accessoren stellen die Schnittstelle dar, über die die für den Anwender sichtbare Fluent API bereitgestellt wird. Die Settings hingegen implementieren die zugehörigen Methoden und enthalten die entsprechenden, miteinander verknüpften Daten, die beim Aufbau der Konfiguration ausgelesen werden.

Programm \ref{prog:example_setting_with_accessor} zeigt ein Beispiel für den Aufbau von Accessoren und Settings. Das Setting enthält Informationen darüber, wann der weiter konfigurierte Wert einer Ansicht oder eines Präsentationsmodells ausgelesen wird. Die Eigenschaften werden dabei mithilfe eines Record-Typs \cite{microsoft_csharp_records} unter Berücksichtigung von nullable bzw. Optionalen Eigenschaften (siehe Unterabschnitt \ref{subsec:csharp_null_reference_types}) bereitgestellt.

Der Zugriffstyp IActionTriggerSettingAccessor definiert, wie das Setting weiter ausgebaut werden kann. In diesem Fall kann eine Property aus dem Kontext gewählt werden. Das daraus resultierende Setting ist, wie in der Schnittstelle beschrieben, ein vollständiges Setting, das mithilfe der ApplySetting-Methode aus dem Interface IConfigurationEndSettingAccessor dem TargetConfigurationBuilder hinzugefügt wird.

\begin{program}[H]
\begin{CsCode}
public interface IActionTriggerSettingAccessor<TContext> : IConfigurationSettingAccessor{
    IConfigurationEndSettingAccessor SelectProperty<TValue, TResult>(
        Expression<Func<TContext, TValue>> propertySelector,
        Func<TValue, TResult>? propertyConverter = null,
        string? description = null);
}
internal record ActionTriggerSetting<TContext>(
    IActivityTrackingConfigurationBuilder TargetConfigurationBuilder,
    ContextType ContextType,
    IActivityTrackingActionIdentifier Action) : IActionTriggerSettingAccessor<TContext>,IConfigurationSetting<IActivityTrackingConfigurationBuilder>
    {
    public IConfigurationEndSettingAccessor SelectProperty<TValue, TResult>(
        Expression<Func<TContext, TValue>> propertySelector,
        Func<TValue, TResult>? propertyConverter = null,
        string? description = null){
        var propertyDataProviderParameter = new PropertyDataProviderParameter(propertySelector, propertyConverter,description);
        return new DataSelectionSetting(TargetConfigurationBuilder, ContextType, 
                                        typeof(TContext), Action,
                                        propertyDataProviderParameter);
    }
}
\end{CsCode}
\caption{Beispiel für Settings und Accessoren.}
\label{prog:example_setting_with_accessor}
\end{program}

\subsection{Erzeugen der Aufträge für das Datensammeln und Extrahieren}
Die gesammelten Einstellungen werden, im Builder mit der Schnittstelle IConfigurationSettingHolder zusammengeführt und beim Aufruf der Build-Methode verarbeitet. Die Builder in den darunterliegenden Schichten sind für die Delegation dieses Aufrufs sowie für die Gruppierung der untergeordneten Builder verantwortlich. Dadurch übernehmen die Blätter des Konfigurationsbaums die eigentliche Arbeit beim Aufbau der Konfiguration. Die Verarbeitung der Settings wird anhand eines Beispiels im Programm \ref{prog:example_processing_of_settings} für Tracking-Aufträge erläutert. Die Vorgehensweise für Extraktionsaufträge erfolgt analog. Wie im Programm dargestellt, leitet die Build-Methode die gesammelten Settings an die Methode BuildTrackingMissionAsync weiter. Diese Methode erzeugt für jeden Setting-Typ einen entsprechenden Auftrag für das Tracking.

\begin{program}[H]
\begin{CsCode}
protected override Task<TrackingMissionData> BuildTrackingMissionAsyn(
    IReadOnlyList<ICompletedConfigurationSetting<IActivityTrackingConfigurationBuilder>> appliedSettings) =>
        Task.FromResult(new TrackingMissionData(appliedSettings.Select(cs => {
            if (cs is DataSelectionSetting dataSelectionSetting)
            {
                return new TrackingMissionDataEntry(dataSelectionSetting.Context,
                                                    dataSelectionSetting.Action,
                                                    typeof(PropertyDataProviderTemplate),
                                                    dataSelectionSetting.PropertyParameter);
            }
            throw new NotSupportedException(...);}).ToList()));
\end{CsCode}
\caption{Beispiel für die Verarbeitung von Settings zu Tracking-Aufträgen.}
\label{prog:example_processing_of_settings}
\end{program}

\section{Daten- und Aktionsermittlung}
\label{sec:data_collection_impl}
Im vorherigen Abschnitt wurde erläutert, wie die Aufträge mithilfe der Konfiguration erzeugt werden. In diesem Abschnitt wird näher beschrieben, wie diese Aufträge abgearbeitet werden und wie die einzelnen Komponenten zur Datenbeschaffung implementiert sind.

\subsection{Provider Template für Aktionen}
Um Daten zu sammeln, müssen diese, wie bereits im Unterabschnitt \ref{sec:data_extraction_concept} beschrieben, von sogenannten Providern bereitgestellt werden. Damit ein Provider Daten liefern kann, muss er sich zunächst registrieren. Nach erfolgreicher Registrierung erhält er, abhängig vom jeweiligen Trackingauftrag, Zugriff auf einen Datenkanal, über den die gesammelten Daten zur weiteren Verarbeitung bereitgestellt werden können.

Für die Implementierung dieser Provider werden im Framework Templates im Sinne des Template-Musters \cite{gamma1995design} verwendet. Diese Templates kommen sowohl für Aktionen als auch für andere Arten von Daten zum Einsatz. Da die Implementierung beider Varianten weitgehend identisch ist, wird in diesem Abschnitt das Basis-Template für Aktionen erläutert, das in Programm \ref{prog:base_template_actions} dargestellt ist. Dieses Template dient als Grundlage für aktionsspezifische Templates.

\begin{program}[H]
\begin{CsCode}
public abstract class ActivityTrackingActionProviderTemplateBase : IActivityTrackingActionProvider{
    public void Initialize(){
        var dataCollectionEntryPoint = GetDataCollectionEntryPoint();
        foreach (var context in GetContextObjects()){
            if (dataCollectionEntryPoint.TryEstablishActionProviderCollaboration(
                    this, context, out var publishChannel, out var suggestedIdentifiers))
            {
                ...
            }
        }
        ...
        InitializeCore();
    }
    public void Dispose(){
        DisposeCore();
        ...
    }
    public void CancelDataCollectionCollaboration() => Dispose();
    protected void PublishAction(IActivityTrackingAction action, Action<IActivityTrackingAction> publishChannel){
        ...
        publishChannel.Invoke(action);
    }
    protected abstract void InitializeCore();
    protected abstract void DisposeCore();
    protected abstract IActivityTrackingDataCollectionCollaborationEntryPoint GetDataCollectionEntryPoint();
    protected abstract object[] GetContextObjects();
    protected abstract string GetContextInfo(object? context);
}
\end{CsCode}
\caption{Basis Template für Aktionen.}
\label{prog:base_template_actions}
\end{program}

\subsubsection{Initialisierung}
Die Methode Initialize stellt die Verbindung zum Trackingsystem über den IActivityTrackingDataCollectionCollaborationEntryPoint für die verschiedenen Kontextobjekte, wie beispielsweise Ansichten oder Präsentationsmodelle her. Diese Informationen erhält die Methode über die von der Anwendung implementierten, abstrakten Methoden.

Der EntryPoint ist im Wesentlichen ein Interface, das vom Manager der Datensammlung implementiert wird. Der jeweilige Kontext sowie Metainformationen des konkreten Templates werden beim Registrieren verwendet, um zu entscheiden, ob ein Datenkanal bereitgestellt werden soll. Bei erfolgreicher Registrierung erhält die konkrete Implementierung die Möglichkeit, weitere Initialisierungsschritte für das Tracking durchzuführen.

\subsubsection{Datenbereitstellung}
Die Methode PublishAction übernimmt den Kanal zur Bereitstellung der Daten. Dieser Kanal wird beim Registrierungsprozess hinterlegt und beim Aufruf der PublishAction-Methode übergeben. Bevor die Daten tatsächlich weitergegeben werden, erfolgen Prüfungen, beispielsweise ob die Zusammenarbeit mit dem Trackingsystem weiterhin aktiv ist.

\subsubsection{Abmeldung und Freigabe verwalteter Ressourcen}
Das Template stellt außerdem die Methoden CancelDataCollectionCollaboration und Dispose bereit, die vom Trackingsystem verwendet werden, um bei Fehlern oder bei einer gezielten Deaktivierung des Trackings im laufenden Betrieb die genutzten Ressourcen sowie die Kommunikation mit dem Trackingsystem kontrolliert zu beenden. Wie auch bei der Initialisierung müssen in den abgeleiteten Klassen die entsprechenden Methoden implementiert werden, um dort spezifische Ressourcen freizugeben.

\subsubsection{Weitere Merkmale des basis Templates}
Im Programm \ref{prog:base_template_actions} werden einige Teile ausgeblendet, um den Fokus auf den Lebenszyklus zu belassen. Denoch ist zu erwähnen das an diesen Stellen bereits eine zentrale Fehlerbehandlung vorgenommen wird. Somit wird über den gesamten Lebenszyklus sichergestellt, dass das Programm aufgrund von Trackingaktivitäten nicht zum stillstand kommt.

\subsection{Auftragsabarbeitung}
Wie bereits erwähnt, wird bei der Registrierung entschieden, ob ein Provider aktiv werden kann. Dies stellt sicher, dass Ressourcen nur dann verwendet werden, wenn sie tatsächlich benötigt werden, also konkret dann, wenn ein entsprechender Auftrag vorliegt. Wie diese Entscheidung getroffen wird, ist im Programm \ref{prog:registration_code_snipped} dargestellt. Die Entscheidung selbst wird vom Manager der Datensammlung über diese Methode vorgenommen. Bei der Registrierung werden darüber hinaus weitere Aspekte berücksichtigt, beispielsweise der Schutz vor mehrfacher Registrierung und ähnliche Validierungen.

Der zugrunde liegende Code zeigt, dass grundsätzlich jede Aktion einen Identifier mit Informationen über die Aktion bereitstellt. Dies hat den Vorteil, dass unterschiedliche Aktionen über einen gemeinsamen Identifier-Typ abgebildet werden können und die Aktionen dadurch flexibel erweiterbar sind. Auf Basis des Identifier-Typs und des jeweiligen Kontexts wird entschieden, ob ein Provider benötigt wird. Welche Aktionen ein Provider bereitstellen kann, gibt dieser über ein Attribut an, das mithilfe der Methode GetActionIdentifiersForActionProvider per Reflection  (Unterabschnitt \ref{subsec:reflection}) ausgelesen wird.

Wie zu erkennen ist, handelt es sich hierbei zunächst nur um eine grobe Einschränkung. Die eigentliche Filterung (siehe Abschnitt \ref{sec:data_extraction_impl}) erfolgt erst im Anschluss. In diesem Schritt wird lediglich entschieden, dass Daten aus einer bestimmten Ansicht und Kategorie ermittelt werden sollen.

\begin{program}[H]
\begin{CsCode}
public bool IsActionProviderRequired(IActivityTrackingActionProvider actionProvider, 
                                     object context)
{
        var availableActions = GetActionIdentifiersForActionProvider(actionProvider);

        return Entries.Any(e => 
                    e.ActionIdentifier != null && 
                    availableActions.Contains(e.ActionIdentifier.GetType()) &&
                    (e.Context == null || e.Context.IsAssignableFrom(context.GetType())));
}
private IList<Type> GetActionIdentifiersForActionProvider(
                        IActivityTrackingActionProvider actionProvider)
{
        return actionProvider
            .GetType()
            .GetCustomAttributes(typeof(ActionProviderForActionAttribute<>), true)
            .Select(ap => ap.GetType().GetGenericArguments().First())
            .ToList();
}
\end{CsCode}
\caption{Tracking Provider Registierung Entscheidungsgrundlage.}
\label{prog:registration_code_snipped}
\end{program}

\section{Filterung und Extraktion}
\label{sec:data_extraction_impl}
Im Abschnitt \ref{sec:data_extraction_concept} wurde bereits erläutert, dass die zuvor ermittelten Daten in einer asynchronen Umgebung weiterverarbeitet werden müssen, um sie präzise an die Anforderungen der Konfiguration anzupassen. Wie diese Verarbeitung umgesetzt wurde, wird im folgenden Abschnitt beschrieben.

\subsection{Verarbeitungskette Ablauf}
Die eingehenden Daten werden direkt vom Manager für Datenverarbeitung an eine initialisierte Verarbeitungskette weitergegeben. Diese nimmt die Daten entgegen und erzeugt für jedes Element einen Task, der in eine Warteschlange eingereiht wird. Die Warteschlange wird anschließend von Hintergrund-Threads asynchron abgearbeitet. Dabei kommt der taskbasierte Ansatz zum Einsatz, der im Unterabschnitt \ref{subsec:async} beschrieben ist.

Das Hinzufügen von Aufgaben wird im Programm \ref{prog:data_processing_chaining} exemplarisch und in vereinfachter Form dargestellt. Treffen die eingehenden Daten, entweder Aktionen oder sonstige Informationen, die in der Methode PushDataAsync als Payload übergeben werden, nicht auf einen gültigen Filter, so werden sie nicht weiterverarbeitet. Die Filter werden sequentiell durchlaufen, und sobald einer der Filter anschlägt, wird die entsprechende Payload verworfen. Wird die Payload hingegen nicht herausgefiltert, durchläuft sie alle Extraktoren, die relevante Daten aus ihr extrahieren können.

Das Filtern der Daten erfolgt über die Methode ApplyFilterAsync, während die Methode ExtractDataAsync für das eigentliche Extrahieren der Informationen verantwortlich ist.

\begin{program}[H]
\begin{CsCode}
public async Task PushDataAsync(IActivityTrackingPayload activityTrackingPayload){
    await _taskQueue.Run(async () =>
    {
        var filteredPayload = await ApplyFiltersAsync(activityTrackingPayload);

        if (filteredPayload is not null)
            await ExtractDataAsync(filteredPayload);
    });
}
\end{CsCode}
\caption{Datenverarbeitung in der Filterkette.}
\label{prog:data_processing_chaining}
\end{program}

Wie bereits erwähnt, ist das dargestellte Programm stark vereinfacht. In der tatsächlichen Implementierung existieren zusätzliche Codeabschnitte, die unter anderem Locking-Mechanismen und Fehlerbehandlung übernehmen. Dadurch wird sichergestellt, dass ein externer Filter oder Extraktor die Ausführung anderer Filter und Extraktoren nicht beeinflussen kann.

Die Filter und Extraktoren können, ähnlich wie bei der Konfiguration (siehe Unterabschnitt \ref{subsec:investigation_of_configuration}), in den einzelnen Assemblies bereitgestellt werden. Sie werden anschließend vom für die Extraktion zuständigen Manager in die Filterkette eingefügt.

\subsection{Extraktion der Daten}
Während Filter die Payload erhalten und Basis dieser Daten entscheiden, ob die Payload weiter verareitet werden soll, werden bei der Extraktion die Daten auf basis eines Trackingauftrags verarbeitet. Wie diese Verabreitung funktioniert, wird in diesem Abschnitt exemplarisch dargestellt.

\subsubsection{Trackingauftrag}
Ein Extraktionsauftrag enthält, ähnlich wie ein Trackingauftrag, Informationen über Aktionen, Metadaten zum Ergebnisobjekt sowie weitere Filterkriterien. Während Trackingaufträge lediglich auf Basis der Kategorie, die über den Aktions-Identifier bestimmt wird, ausgeführt werden, berücksichtigt die Extraktion zusätzlich den Inhalt des Aktions-Identifiers. Dabei wird überprüft, ob der Identifier des Auftrags mit dem Aktions-Identifier der bereitgestellten Aktion kompatibel ist.

Im Programm \ref{prog:data_processing_task} wird ein Beispiel für ein Objekt eines Extraktionsauftrags dargestellt.
Die Kompatibilität eines Identifiers mit einem anderen bedeutet, dass es allgemeinere Identifier gibt, die den Inhalt einer Aktion weniger spezifisch beschreiben. Ein allgemeiner Identifier ist somit mit einem spezifischeren Identifier kompatibel, wodurch die entsprechende Aktion weiterverarbeitet wird.

Bei sonstigen Daten, die keine Aktion darstellen, existiert kein Identifier. Diese Daten werden ausschließlich auf Grundlage weiterer Filterkriterien verarbeitet. Bestimmte sonstige Daten können jedoch ebenfalls einen Identifier besitzen, sofern sie einer Aktion zugeordnet sind.

\begin{program}[H]
\begin{CsCode}
public record ExtractionMissionMetricDataEntry(
ContextType ContextType,
IActivityTrackingActionIdentifier? ActionIdentifier,
Type? Context,
MetricType MetricType) : IActivityTrackingExtractionMissionDataEntry
{
public TrackingSubject TrackingSubject => TrackingSubject.Metrics;
public bool IsMoreSpecificThan(IActivityTrackingExtractionMissionDataEntry other) => ...;
public virtual bool Equals(ExtractionMissionMetricDataEntry? other) => ...;
public override int GetHashCode() => ...;
}
\end{CsCode}
\caption{Extraktionsauftragseintrag für Metriken.}
\label{prog:data_processing_task}
\end{program}

\subsubsection{Daten Extraktion}
Auf Basis des beschriebenen Auftrags kann ein Extraktor entscheiden, ob und wie die vorliegenden Daten verarbeitet werden. Wie auch bei den Filtern existieren hierfür Basisklassen, welche die Verarbeitung durch Hilfsmethoden vereinfachen. Die eigentliche Logik befindet sich jedoch in den spezifischen Extraktoren selbst. Eine Methode zur Extraktion von Aktionen von einem dieser Extraktoren ist in Programm \ref{prog:data_extractor_example} dargestellt.

\begin{program}[H]
\begin{CsCode}
protected override Task ExtractActivityTrackingActionAsync(
    IActivityTrackingAction action, CancellationToken cancellationToken)
{
    if (TryGetMissionEntriesForActionWithContext<ExtractionMissionMetricDataEntry>(
        action, TrackingSubject.Metrics, 
        [typeof(ViewAction), typeof(PresentationModelAction)],
        mde => mde.MetricType == MetricType.ViewUsage, out var entries))
    {
        ...
        ReplaceExistingExtraction<ExtractionViewUsageData>(existingExtraction =>
        {
            return new ExtractionViewUsageData(
                  entries.First().ContextType,
                  action.ActionIdentifier.Context!,
                  action.ContextInfo!,
                  (existingExtraction?.ViewUsageCount ?? 0) + 1);
        },
        ed => ed.Context == action.ActionIdentifier.Context);
    }
    return Task.CompletedTask;
}
\end{CsCode}
\caption{Daten Extraktion für Metriken}
\label{prog:data_extractor_example}
\end{program}

Zunächst wird nach einem Auftrag gesucht, der mit der eingehenden Aktion übereinstimmt. Wird ein solcher Auftrag gefunden, wird die Aktion weiterverarbeitet. Wie im Konzept \ref{sec:data_collection_concept} beschrieben, wird dabei zunächst geprüft, ob bereits gespeicherte, passende Daten vorhanden sind. Falls dies der Fall ist, werden die neuen Informationen mit den bestehenden Daten aggregiert. Wird im Beispiel etwa eine Ansicht mehrfach geöffnet, existiert beim Auslesen der Daten nur ein Eintrag, der die Anzahl der Aufrufe dieser Ansicht enthält. Für sonstige Daten, die auf Aktionen basieren oder eigenständig publiziert werden, existiert eine ähnliche Methode. Diese führt die Filterung jedoch auf Grundlage einer referenzierten Aktion oder anderer Kriterien durch. Die eigentliche Umsetzung, insbesondere die Verwendung der Methode ReplaceExistingExtraction, wird dabei beibehalten.

\section{Integration des Tracking Frameworks}
\label{sec:integration_wpf_impl}
Um das Framework zu integrieren muss das Framework in der Anwendung Initialisert werden und die Provider sowie Konfiguration in den verwendeten Projekten bereitgestellt werden. Wie dies umgesetzt wurde wird diesem Abschnitt beschrieben.

\subsection{Initialisierung des Tracking Frameworks}
Um das Framework zu initialisieren, werden die Komponenten zunächst in einen Dependency Injection Container eingefügt. 

\begin{program}[H]
\begin{CsCode}
public sealed class RZLActivityTrackingSystemConfiguration 
    : IActivityTrackingSystemConfiguration, IBootable{
    public IAssemblyProvider AssemblyProvider { get; private init; }
    public Func<Task<bool>> IsTrackingEnabledAsync { get; private init; }
    public Func<IList<IActivityTrackingExtractionData>, Task<object>> ConvertToResultDataAsync 
        => ActivityTrackingResultConversionHelper.SerializeToJson;
    public Func<object, Task<bool>> TrackingDataPublishAsyncChannel => 
        (input) => { Debug.WriteLine(input); return Task.FromResult(true); };
    public Action<ActivityTrackingException> ExceptionHandler { get; set; } = 
        ex => #if DEBUG throw ex; #endif
    ...
    public RZLActivityTrackingSystemConfiguration(
        IActivityTrackingMainManager mainManager,
        IUsabilityLogAgreementService usabilityLogAgreementService,
        IMVVMConfiguration mvvmConfiguration){
        _mainManager = mainManager;
        AssemblyProvider = new RZLActivityTrackingAssemblyProvider();
        IsTrackingEnabledAsync = usabilityLogAgreementService
                                    .IsRZLAllowedToSendUsablilityInformationFromUserAsync;
        usabilityLogAgreementService.OnLoggingAgreementChanged += 
                            (_, _) => _mainManager.NotifyIsTrackingEnabledChanged();
    }

    public async ValueTask ExecuteAsync(IBootContext bootContext, IBootParameter _)
        => await _mainManager.InitializeAsync(this);
}
\end{CsCode}
\caption{Systemkonfiguration und Systeminitialisierung.}
\label{prog:system_initialization_and_configuration}
\end{program}

Die Systemkonfiguration ist eine besondere Abhängigkeit und stellt eine Methode bereit, die zu einem bestimmten Zeitpunkt im Bootprozess aufgerufen wird. Dieser Zeitpunkt wird durch die Abhängigkeiten bestimmt. Die Methode initialisiert anschließend das Tracking-System über den zentralen Hauptmanager. Die Konfiguration liefert dabei die benötigten Informationen. Die Systemkonfiguration wird im Programm \ref{prog:system_initialization_and_configuration} dargestellt.

Die Abhängigkeit IMVVMConfiguration im Konstruktor wird zwar nicht direkt verwendet, hat jedoch die Aufgabe, die Konfiguration erst zum richtigen Zeitpunkt zu initialisieren, wie bereits erwähnt. Die Eigenschaften sind im Programm beispielhaft implementiert und können je nach Anwendung variieren. Im Testprogramm werden die Daten daher in JSON umgewandelt und in der Konsole ausgegeben. In einem produktiven System würden die Daten über einen Service an einen Server übermittelt.

Exceptions werden im Testprogramm einfach weitergeworfen, um den Stillstand sichtbar zu machen, in einem Echt-System wäre an dieser Stelle Logging vorgesehen. Ob Tracking durchgeführt werden kann, wird in diesem System bereits über einen Service geprüft, der über das Programm angesteuert werden kann.

Der AssemblyProvider ist je nach Anwendung unterschiedlich und gibt an, welche Projekte für die Konfiguration, Filter und Extraktoren berücksichtigt werden sollen.

\subsection{Integration Windows Forms}
Wenn die Anwendung eine Systemkonfiguration bereitstellt, fehlen nur mehr die Provider die entsprechenden Daten bereitstellen. Diese müssen je System implementiert werden und mit den Ansichten Verknüft werden. In diesem Abschnitt wird erläutert, wie dies für Windows Forms umgesetzt wurde. 

\subsubsection{Integration der Provider}
In Windows Forms werden die Provider als Embedded Presenter (siehe Unterabschnitt \ref{subsec:embedded_presenter}) bereitgestellt. Dazu wird in einer der Basisklassen in der Methode, in der solche Extensions hinzugefügt werden, die in Programm \ref{prog:add_provider_to_winforms} gezeigte Methode aufgerufen und die Provider hinzugefügt.

\begin{program}[H]
\begin{CsCode}
public static IList<KISEmbeddedPresenterBase> GetEmbeddedPresenterForActivityTracking(
    this KISStandalonePresenterBase standalonePresenter){
    var activityTrackingMainManager = standalonePresenter.Container
                                            .GetService<IActivityTrackingMainManager>();

    if (activityTrackingMainManager is null || !activityTrackingMainManager.IsInitialized)
        return [];

    return[standalonePresenter.GetEmbeddedPresenter<LoadTimeDataProviderEmbeddedPresenter>(standalonePresenter, false),
           standalonePresenter.GetEmbeddedPresenter<PresenterActionProviderEmbeddedPresenter>(standalonePresenter, false),
           ...];
}
\end{CsCode}
\caption{Bereitstellung der Provider unter Windows Forms.}
\label{prog:add_provider_to_winforms}
\end{program}

Die Provider werden jedoch nur dann hinzugefügt, wenn das Tracking-System aktiv ist, um die Laufzeit beim Registrieren zu reduzieren. Dieser Schritt ist daher nur notwendig, um die Performance zu verbessern.

\subsection{Integration WPF}
In WPF werden die Provider über Presenter-Extensions (siehe Unterabschnitt \ref{subsec:presenter_extensions}) bereitgestellt. Diese Extensions können in der MVVM-Konfiguration, deren Zusammenhang mit den Presenter-Extensions im Unterabschnitt erklärt wird, konfiguriert werden. Dazu wird die im Programm \ref{prog:add_provider_to_wpf} dargestellte Methode verwendet. Diese fügt die Erweiterungen, wie auch bei Windows Forms, nur hinzu, wenn das Tracking-System tatsächlich aktiv ist.

Zur Ermittlung des Initialized-Events wird zusätzlich eine ViewModel-Extension (siehe Unterabschnitt \ref{subsec:viewmodel_extensions}) benötigt. Diese ist die einzige Extension, die direkt dem Basis-ViewModel hinzugefügt werden muss, damit sie für alle weiteren ViewModels verfügbar ist und beim Erzeugen sowie Hinzufügen der Provider genutzt werden kann.

\begin{program}[H]
\begin{CsCode}
public static PresenterExtensionConfig<RZLViewModelBase> CreatePresenterExtensionConfig() =>
    new PresenterExtensionConfig<RZLViewModelBase>((p, vm) => {
       var dataCollectionEntryPoint = MVVMApplication.Container.GetService<IActivityTrackingDataCollectionCollaborationEntryPoint>();
       var activityTrackingMainManager = MVVMApplication.Container.GetService<IActivityTrackingMainManager>();
       var viewModelInitializedEventVMX = vm.GetViewModelExtension<ViewModelInitializedEventVMX>();

       if (activityTrackingMainManager is null || !activityTrackingMainManager.IsInitialized ||
           dataCollectionEntryPoint is null || viewModelInitializedEventVMX is null)
           return [];

       IActivityTrackingProviderPresenterExtension[] presentersExtensions = [
           new PropertyDataProviderPX(vm, p.View, dataCollectionEntryPoint),
               new LoadTimeDataProviderPX(viewModelInitializedEventVMX, vm, p.View, dataCollectionEntryPoint),
               new ViewModelActionProviderPX(viewModelInitializedEventVMX, vm, p.View, dataCollectionEntryPoint),
               ...
       ];
       presentersExtensions.ForEach(pe => pe.Initialize());
       return presentersExtensions;
   });
\end{CsCode}
\caption{Bereitstellung der Provider unter WPF}
\label{prog:add_provider_to_wpf}
\end{program}

\subsection{Erstellen eines spezifischen Provider}
Anhand eines Beispiels soll gezeigt werden, wie ein spezifischer Provider erstellt wird. Für dieses Beispiel wurde ein Aktions-Provider für WPF herangezogen. Dieser wird im Programm \ref{prog:action_provider_wpf_example} dargestellt.

Das gezeigte Programm implementiert einen Aktions-Provider, der die in einer Ansicht verwendeten Shortcuts ermittelt. Dazu implementiert der Provider das KeyboardActionProviderTemplate und wird mithilfe einer Adapter-Klasse zu einer IActivityTrackingProviderPresenterExtension. Der Provider bindet die vom Template bereitgestellten Handler an die entsprechenden Events, die beispielsweise über RoutedEvents (siehe Unterabschnitt \ref{subsec:WPF}) ausgelöst werden. Diese Events müssen dabei auf das richtige Handler-Format übertragen werden.

Der Provider übergibt dem Template außerdem die Schnittstelle zur Registrierung sowie die Objekte, die als gültiger Kontext für die Bereitstellung von Daten in Frage kommen. Für Shortcuts können in der Konfiguration daher sowohl das ViewModel als auch die View angegeben werden. Das Template übernimmt anschließend die weitere Verarbeitung und übermittelt die erfassten Informationen an das Tracking-Framework.

Während der Verarbeitung werden Methoden wie GetKeyEventInfo und GetContextInfo aufgerufen, die es ermöglichen, zusätzliche Informationen aus dem Event sowie dem Context auszulesen und bereitzustellen. Der Detailgrad der gesammelten Daten hängt dabei insbesondere von der Granularität der verwendeten Provider ab.

\begin{program}[H]
\begin{CsCode}
internal sealed class KeyboardActionProviderPX : IActivityTrackingProviderPresenterExtension{
    ... 
    public void Initialize(){
        if (_dataCollectionCollaborationEntryPoint is null)
            return;

        _keyboardActionProvider = new KeyboardActionProvider(_viewModel, _view, _dataCollectionCollaborationEntryPoint);
        _keyboardActionProvider.Initialize();
    }

    private class KeyboardActionProvider : KeyboardActionProviderTemplate{
        ...
        private void KeyEventHandlerAdapter(object sender, KeyEventArgs args) => 
            _keyEventHandler?.Invoke(sender, args);
        private void ViewLeavedHandlerAdapter(object sender, RoutedEventArgs args) =>  
            _viewLeavedHandler?.Invoke(sender, args);
        protected override object[] GetContextObjects() => [_view, _viewModel];
        protected override string GetContextInfo(object? context) => ...
        protected override IActivityTrackingDataCollectionCollaborationEntryPoint 
            GetDataCollectionEntryPoint() => _dataCollectionCollaborationEntryPoint;
        protected override (string Key, bool SignalsLast)? GetKeyEventInfo(EventArgs args) 
            => ...
        protected override void RegisterShortcutEventHandler(EventHandler handler){
            _keyEventHandler += handler;
            _view.PreviewKeyUp += KeyEventHandlerAdapter;
            _view.PreviewKeyDown += KeyEventHandlerAdapter;
        }
        protected override void UnregisterShortcutEventHandler(EventHandler handler) => ...
        protected override void RegisterViewLeaved(EventHandler eventHandler){
            _viewLeavedHandler += eventHandler;
            _view.LostFocus += ViewLeavedHandlerAdapter;
        }
        protected override void UnregisterViewLeaved(EventHandler eventHandler) => ...
    }
}
\end{CsCode}
\caption{Provider für Aktionen WPF Beispiel.}
\label{prog:action_provider_wpf_example}
\end{program}


